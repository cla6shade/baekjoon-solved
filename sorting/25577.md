# 25577 (PNU Coderace Open Contest)

[문제 링크](https://acmicpc.net/problem/25577)

## 문제

열정이 가득한 김정렬은 항상 배열을 오름차순 정렬하려고 하는 강박증이 있다.

하지만 너무 열정적으로 정렬한 나머지 제대로 정렬하지 못하는 경우가 생긴다.

김정렬의 친구로서, 정렬이가 눈치채기 전에 다시 정렬시켜주려고 한다. 하지만 배열을 너무 많이 바꿀 경우 정렬이가 눈치를 채게 되고, 정렬이는 낙담할 것이다.

우리가 배열에 적용할 수 있는 연산은 임의의 두 값을 뽑아서 서로 교환하는 것이다. 정렬이 몰래 정렬하기 위해 최소한으로 필요한 연산 횟수를 구하자.

### 입력
    첫 번째 줄에 배열의 크기 N(4 ≤ N ≤ 100,000)이 주어진다.
    그다음 줄에 배열의 원소 A_1, A_2, cdots, A_n (-10^9 ≤ A_i ≤ 10^9, i !== j  이면  A_i !== A_j ) 이 주어진다.
    배열의 원소는 모두 정수이다.
### 출력
    배열에 적용할 최소 연산 횟수를 출력한다.

## 정리

어제 부산대학교 대회에서 풀었던 문제다. 두 원소를 뽑아서 정렬하는 형태가 어디서 많이 봤다 싶었는데
집에와서 보니까 선택 정렬을 응용한 형태였다. 

문제 풀 때 당시의 발상

    어차피 정렬할건데 시간복잡도 낮은 내장함수로 미리 정렬해서 복사해놓고
    정렬해논 배열과 정렬되지 않은 배열을 비교하면서 각 원소가 순서대로 들어갈 수 있도록 삽입하면 되지 않을까?

뇌에 이미 선택정렬의 원리가 담겨있긴 했는데 확실치는 않았던 모양이다.
정렬 알고리즘의 발상을 기억해서 응용 문제를 풀 수 있도록 해야겠다.

```python
import sys

input = sys.stdin.readline

n = int(input())
arr = list(map(int, input().split()))
s = sorted(arr) #정렬된 arr

k = 0
count = 0
for i in range(n):
    if arr[i] == s[i]:
        k += 1
        continue
    temp = arr[i]
    obj = s[k]
    
    index = arr.index(obj)
    # swap
    arr[i] = obj
    arr[index] = temp
    k += 1
    count += 1

print(count)

```